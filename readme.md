## Тесты

### Реализовано:
- store:
  - поднимается контейнер с Redis-хранилищем
  - Redis-хранилище задумано как одно хранилище с двумя пространствами: `i` - для хранения `clients_interests`; `cache` - для хранения кеша при запросах с методом `online_score`;
  - Store - класс для подключения к Redis-хранилищу, взаимодействия с ним;
  - функционал повторного подключения к Redis и timeout'ы;
  - скрипт для наполнения Redis тестовыми данными `scripts/fill_redis_for_test.py`
- Тесты:
  - unit-тесты:
    - "функциональные" тесты с прощлого ДЗ перенесены в `tests/functional/`
    - добавлены тесты классов каждого поля - `tests/unit/fields/`;
    - добавлены тесты классов запросов - `tests/unit/requests/`;
    - добавлены тесты scoring-методов - `tests/unit/scoring/`
  - интеграционные тесты:
    - тестирование работы get, set, cache_get и cache_set методов Store (класс для взаимодействия с Redis=хранилищем)
    - тестирование работы get_score и get_interests с поднятым Redis.

## Порядок запуска

### Через make:
```commandline
# собрать все необходимые контейнеры и запустить тесты
# наполнить Redis тестовыми данным
make test
```

### Через docker-compose
```commandline
# 1. Собрать контейнеры и запустить
docker-compose up --build -d

# 2. Наполнить Redis тестовыми данными
docker-compose exec api_scoring python3 -m scripts.fill_redis_for_test

# 3. Запустить тесты
docker-compose exec api_scoring pytest -v tests/
```


## Задание
### Scoring API Tests

*Задание*: протестировать HTTP API сервиса скоринга. Шаблон уже есть в test.py, само API реализовывалось в прошлой части ДЗ. Тесты, выданные ранее, можно считать функциональными и уже готовыми.
1. Необходимо разработать модульные (unit) тесты на основной функционал. Разрешается пользоваться любым тестовым фреймворком: unittest, nosetests, pytest.
2. Обязательно необходимо реализовать через декоратор функционал запуска кейса с разными тест-векторами (Либо, в качестве альтернативы, сделать тоже самое через фикстуры в pytest). Если берете готовый cases, то его надо допилить так, чтобы припадении теста было ясно какой кейс упал.

```
    @cases([
        {"account": "horns&hoofs", "login": "h&f", "method": "online_score", "token": "", "arguments": {}},
        {"account": "horns&hoofs", "login": "h&f", "method": "online_score", "token": "sdd", "arguments": {}},
        {"account": "horns&hoofs", "login": "admin", "method": "online_score", "token": "", "arguments": {}},
    ])
    def test_bad_auth(self, request):
    	...
```

3. store, который был захардкожен в None, наконец обретает смысл! нужно реализовать в store.py общение с любым клиент-серверным key-value хранилищем (tarantool, memcache, redis, etc.) согласно интерфейсу заданному в обновленном scoring.py. Обращение к хранилищу не должно падать из-за разорванного соединения (т.е. store должен пытаться переподключаться N раз преждем чем сдаться) и запросы не должны залипать (нужно использовать timeout'ы где возможно).
	* У store есть отдельно `get` и `cache_get`. В реальной системы, аналогом которой является API из ДЗ, есть отдельный кеш и отдельный key-value storage. Методы названы по-разному, чтобы показать что есть разница. В данном случае, внутри можно реализовать это и как хождение в одно и тоже хранилище. Важно то, как это будет протестировано с учетом разных требований для разных функций.  Обратите внимание, функции `get_score` не важна доступность store'а, она использует его как кэш и, следовательно, должна работать даже если store сгорел в верхних слоях атмосферы. `get_interests` использует store как персистентное хранилище и если со store'ом что-то случилось может отдавать только ошибки.
4. (задание со "звездочкой") добавить интеграционные тесты нового функционала c реальным хранилищем.
5. Структура тестов https://realpython.com/python-testing/#writing-integration-tests

*Цель задания*: применить знания по тестированию, полученные на занятии. В результате получится прокачать навык дизайна тест-кейсов, разработки модульных и функциональных тестов, создания mock'ов.

*Критерии успеха*: задание __обязательно__ кроме частей со "звездочкой", котороые являются расширением основного фуонкционала и выполняются по возможности. Критерием успеха является работающий согласно заданию код, для которого проверено соответствие pep8, написана минимальная документация с примерами запуска, в README, например. Далее успешность определяется code review.

## Deadline
Задание нужно сдать через неделю. То есть ДЗ, выданное в понедельник, нужно сдать до следующего занятия в понедельник. Код, отправленный на ревью в это время, рассматривается в первом приоритете. Нарушение делайна (пока) не карается, пытаться сдать ДЗ можно до конца курсы. Но код, отправленный с опозданием, когда по плану предполагается работа над более актуальным ДЗ, будет рассматриваться в более низком приоритете без гарантий по высокой скорости проверки

## Обратная связь
Cтудент коммитит все необходимое в свой github/gitlab репозитарий. Далее необходимо зайти в ЛК, найти занятие, ДЗ по которому выполнялось, нажать “Чат с преподавателем” и отправить ссылку. После этого ревью и общение на тему ДЗ будет происходить в рамках этого чата.
